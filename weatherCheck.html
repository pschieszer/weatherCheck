<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Weather Viewer</title>
		<style type="text/css">
        * { margin:0; padding:0; }

        body {
            margin: 0.9rem;
            color: white;
            text-shadow: -0.05em -0.05em black, -0.05em 0.05em black, 0.05em -0.05em black, 0.05em 0.05em black;
            -webkit-background-size: cover;
            -moz-background-size: cover;
            -o-background-size: cover;
            background-size: cover;
            height: 100%;
            min-height: 100%;
            background-repeat: no-repeat;
            background-attachment: fixed;
            background-position: center center;
            font: 18px sans-serif;
        }

        #refresh {
            border: 0;
            line-height: 2.5;
            padding: 0 20px;
            font-size: 1rem;
            color: #fff;
            text-shadow: 1px 1px 1px #000;
            border-radius: 20px;
            background-color: rgba(220, 0, 0, 1);
            background-image: linear-gradient(to top left, rgba(0, 0, 0, .2), rgba(0, 0, 0, .2) 30%, rgba(0, 0, 0, 0));
            box-shadow: inset 2px 2px 3px rgba(255, 255, 255, .6), inset -2px -2px 3px rgba(0, 0, 0, .6);
        }

        .centered {
            width: 100%;
            text-align: center;
        }
        
        .conditions {
            z-index:2;
			background-color: hsla(77, 65%, 45%, 0.44);
            position: fixed;   
        }

        #searchResults {
            position:relative;
        }

        td {
			padding-left: .2rem;
			padding-right: .2rem;
			text-align: center;
		}
		</style>

		<meta name="author" content="Patrick Schieszer">
		<meta name="description" content="Weather checker">
		<meta name="robots" content="all">
	</head>
	<script>
	const inHgPerPa = 0.0002953;
	const inPerMeter = 39.3701;
    const HOME_LOC = "38.6270074,-90.1912848";
	const hourFormat = { weekday: 'short', hour: 'numeric'};
	const hourMinFormat = { weekday: 'short', hour: 'numeric', minute: 'numeric' };
    const geoHeaders = { headers: { "accept": "application/geo+json" } };
    const geoOptions = { maximumAge: 5 * 60 * 1000, timeout: 5 * 1000 };
	
	getDateString = (date, dateFormat) => new Intl.DateTimeFormat('en-US', dateFormat).format(date);
	
	formatDate = (date, dateFormat = hourFormat) => (date instanceof Date) ? getDateString(date, dateFormat) : date;
	
	buildCell = x => {
		const td = document.createElement('TD');
		td.appendChild(x);
		return td;
	};
	
	buildTextCell = x => buildCell(document.createTextNode(x));
	
	buildImage = (src, text) => {
		const img = new Image();
		img.src = src;
		img.title = img.alt = text;
		return img;
	};
        
    getDateRange = (start, end) => formatDate(start) + " to " + formatDate(end);
	
	addRow = (image, imageAlt, start, temp, end, wind) => {
		const tableBody = document.getElementById("data");
		const tr = document.createElement('TR');
		const td = (image && image.length > 0) ? 
			buildCell(buildImage(image, imageAlt)) : buildTextCell(image);
		tr.appendChild(td);
		
		const elemTexts = [ getDateRange(start, end), temp, wind ];
		elemTexts.map(buildTextCell).forEach(x => tr.appendChild(x));
		tableBody.appendChild(tr);
	};
	
	getDate = strDate => new Date(strDate);
	
	getWind = period => period.windDirection + " " + period.windSpeed;

	parseForecast = forecast => {
		if (forecast.properties && forecast.properties.periods) {
			forecast.properties.periods.forEach(currPeriod =>
				addRow(currPeriod.icon, currPeriod.shortForecast, getDate(currPeriod.startTime),
				       currPeriod.temperature, getDate(currPeriod.endTime), getWind(currPeriod)));
		}
	};
	
	formattedNum = x => Number.parseFloat(x).toFixed(2);
	
	getFarenheit = x => (x * 9/5) + 32;
	
	setText = (tag, text) => document.getElementById(tag).innerText = text;
        
    getWindChill = windChill => (windChill < 31) ? ", " + windChill + "F wind chill" : "";
    
    getConditionsText = (desc, temp, windChill) => desc + ", " + temp + "F degrees" + getWindChill(windChill);

    setImage = imgSrc => document.body.style.backgroundImage = "url(" + imgSrc + ")";

	getInches = meters => meters * inPerMeter;
	
	formatPrecipitation = properties => {
		var result = "";
		if (properties.precipitationLastHour.value) {
			result += formattedNum(getInches(properties.precipitationLastHour.value)) + "in precipitation in past hour";
		}
		if (properties.precipitationLast3Hours.value) {
			if (result.length() > 0) result += ", ";
			result += formattedNum(getInches(properties.precipitationLast3Hours.value)) + "in precipitation in past 3 hours";
		}
		if (properties.precipitationLast6Hours.value) {
			if (result.length() > 0) result += ", ";
			result += formattedNum(getInches(properties.precipitationLast6Hours.value)) + "in precipitation in past 6 hours";
		}
		return result;
	};

    parseConditions = conditions => {
		if (conditions.properties && conditions.properties.barometricPressure &&
            conditions.properties.barometricPressure.value) {
			const inHg = conditions.properties.barometricPressure.value * inHgPerPa;
			setText("barometricPressure", formattedNum(inHg) + " inches Hg, " +
                    formattedNum(conditions.properties.relativeHumidity.value) + "% relative humidity");
            
			const windChill = formattedNum(getFarenheit(conditions.properties.windChill.value));
			const currTemp = formattedNum(getFarenheit(conditions.properties.temperature.value));
            const desc = conditions.properties.textDescription;
			setText("currTemp", getConditionsText(desc, currTemp, windChill));
            
			setText("currTime", formatDate(getDate(conditions.properties.timestamp), hourMinFormat));

			setText("precipitation", formatPrecipitation(conditions.properties));

            setImage(conditions.properties.icon.replace("medium", "large"));

            document.querySelector('#searchResults').style.top = (document.querySelector('#currLocation').parentElement.offsetHeight + 15) + "px";
		}
	};
	
	startCall = (url, callback) =>
        fetch(url, geoHeaders).then(response => response.json()).then(callback);
        
    getPosition = callback => {
        const enteredLoc = document.getElementById("currLocation").value;
        const DEF_LOC = (enteredLoc) ? enteredLoc : HOME_LOC;
        if (!enteredLoc && ('geolocation' in navigator || navigator.geolocation)) {
            navigator.geolocation.getCurrentPosition(x => callback(x.coords.latitude + "," + x.coords.longitude),
                                                     err => callback(DEF_LOC), geoOptions);
        } else {
            callback(DEF_LOC);
        }
    };
        
	getDistance = (here, far) => Math.sqrt(Math.pow((here[0] - far[0]), 2) + Math.pow((here[1] - far[1]), 2));
	
    compDist = (l, r) => (l.dist < r.dist) ? -1 : (l.dist > r.dist) ? 1 : 0;
        
	getClosestStation = (pos, stations) =>
        stations
        .map(x => ({ src: x, dist: getDistance(pos, x.geometry.coordinates)}))
        .sort(compDist)
        .map(x => x.src);
    
    loadOption = (opt, { geometry: { coordinates: [long, lat] }, properties: { name: statName } }) => {
        opt.value = lat + "," + long;
        opt.text = statName;
        return opt;
    };
        
    buildOption = station => loadOption(document.createElement("option"), station);
        
    buildAlternates = distStations => {
        var locs = document.getElementById("locations");
        if (locs.options.length) Array.from(Array(locs.options.length)).forEach(x => locs.remove(0));
        distStations.map(buildOption).forEach(opt => locs.add(opt, null));
    };
        
    getMyConditions = srcPos =>
		stations => {
            const distStations = getClosestStation(srcPos, stations.features);
            buildAlternates(distStations);
			startCall("https://api.weather.gov/stations/" + distStations[0].properties.stationIdentifier + "/observations/latest", parseConditions);
		};
	
    findStationByPosition = pos => {
        document.getElementById("currLocation").value = pos;
		startCall("https://api.weather.gov/points/" + pos + "/stations", getMyConditions(pos.split(",").reverse()));
        startCall("https://api.weather.gov/points/" + pos + "/forecast/hourly", parseForecast);
    };
        
    getStation = () => {
        const tableBody = document.getElementById("data");
        const rowCount = tableBody.children.length;
        if (rowCount > 0) Array.from(Array(rowCount)).forEach(x => tableBody.deleteRow(0));
        getPosition(findStationByPosition);
    };
    
    useSelectedLocation = x => {
        document.getElementById("currLocation").value = document.getElementById("locations").value;
        getStation();
    };
		
	window.onload = () => {
        document.querySelector('#refresh').addEventListener('click', getStation);
        document.querySelector('#currLocation').addEventListener('change', getStation);
        document.getElementById("locations").addEventListener('change', useSelectedLocation);
        getStation();
    }
	</script>
	<body>
        <div class="conditions centered">
            <label for="location">Location: </label><input type="text" id="currLocation" name="location">
            <input type="button" value="Refresh" id="refresh">
            <div><h3>Weather</h3> (conditions as of <span id="currTime"></span> @ <select id="locations"></select>)</div>
            <div id="currTemp"></div>
            <div id="barometricPressure"></div>
            <div id="precipitation"></div>
        </div>
        <table id="searchResults" class="centered">
            <thead>
                <tr>
                    <th></th>
                    <th>Start to End</th>
                    <th>Temp</th>
                    <th>Wind</th>
                </tr>
            </thead>
            <tbody id="data" />
        </table>
	</body>
</html>