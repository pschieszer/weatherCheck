<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Weather Viewer</title>
		<style type="text/css">
			* { margin:0; padding:0; }
			
			body {
				margin: 0.9rem;
				color: white;
				text-shadow: -0.05em -0.05em black, -0.05em 0.05em black, 0.05em -0.05em black, 0.05em 0.05em black;
				-webkit-background-size: cover;
				-moz-background-size: cover;
				-o-background-size: cover;
				background-size: cover;
				height: 100%;
				min-height: 100%;
				background-repeat: no-repeat;
				background-attachment: fixed;
				background-position: center center;
				font: 18px sans-serif;
			}

			#refresh {
				border: 0;
				line-height: 2.5;
				padding: 0 20px;
				font-size: 1rem;
				color: #fff;
				text-shadow: 1px 1px 1px #000;
				border-radius: 20px;
				background-color: rgba(220, 0, 0, 1);
				background-image: linear-gradient(to top left, rgba(0, 0, 0, .2), rgba(0, 0, 0, .2) 30%, rgba(0, 0, 0, 0));
				box-shadow: inset 2px 2px 3px rgba(255, 255, 255, .6), inset -2px -2px 3px rgba(0, 0, 0, .6);
			}

			.centered {
				width: 100%;
				text-align: center;
			}
			
			.conditions {
				z-index:2;
				background-color: hsla(77, 65%, 45%, 0.44);
				position: fixed;
			}

			#searchResults {
				position:relative;
			}
			
			td {
				padding-left: .2rem;
				padding-right: .2rem;
				text-align: center;
			}

			rect.bordered {
				stroke: #E6E6E6;
				stroke-width:2px;
			}

			text.mono {
				font-size: 9pt;
				font-family: Consolas, courier;
				fill: #aaa;
			}

			text.axis-workweek {
				fill: #000;
			}

			text.axis-worktime {
				fill: #000;
			}
		</style>
		<script src="http://d3js.org/d3.v3.js"></script>

		<meta name="author" content="Patrick Schieszer">
		<meta name="description" content="Weather checker">
		<meta name="robots" content="all">
	</head>
	<script>
		const inHgPerPa = 0.0002953;
		const inPerMeter = 39.3701;
		const HOME_LOC = "38.6270074,-90.1912848";
		const hourFormat = { weekday: 'short', hour: 'numeric'};
		const dowFormat = { weekday: 'short' };
		const hourMinFormat = { weekday: 'short', hour: 'numeric', minute: 'numeric' };
		const geoHeaders = { headers: { "accept": "application/geo+json" } };
		const geoOptions = { maximumAge: 5 * 60 * 1000, timeout: 5 * 1000 };
        
        function HourGrid(forecast) {
            this.forecast = forecast;
            this.dayOffs = [0, 24, 48, 72, 96, 120, 144];
            this.offset = (-1) * new Date(this.forecast[0].startTime).getHours();
            this.findNdx = (day, hour) => (day * 24) + hour;
            this.getHour = (day, hour) => {
                let forecastNdx = this.offset + this.findNdx(day, hour);
                return (forecastNdx > -1 && forecastNdx < forecast.length) ?
                    { 'day': day, 'hour': hour, ...forecast[forecastNdx] } :
                    { 'day': day, 'hour': hour };
            };
            this.getDayNames = () => this.dayOffs.map(x => formatDate(new Date(forecast[x].startTime), dowFormat));
            this.getAllDays = function* () {
                for (var day = 0; day < 7; day++)
                    for (var hour = 0; hour < 24; hour++)
                        yield this.getHour(day, hour);
            };
        }

		heatmapChart = (chartId, forecast, topOffset) => {
            let foreGrid = new HourGrid(forecast);
			let margin = { top: 50, right: 0, bottom: 100, left: 30  },
				width = window.innerWidth - margin.left - margin.right,
				height = window.innerHeight - topOffset - margin.top - margin.bottom,
				gridSize = Math.floor(width / 24),
				legendElementWidth = gridSize * 2,
				buckets = 9,
				colors = ["#ffffd9","#edf8b1","#c7e9b4","#7fcdbb","#41b6c4","#1d91c0","#225ea8","#253494","#081d58"], // alternatively colorbrewer.YlGnBu[9]
				days = foreGrid.getDayNames(),
				times = ["mid", "1a", "2a", "3a", "4a", "5a", "6a", "7a", "8a", "9a", "10a", "11a", "noon", "1p", "2p", "3p", "4p", "5p", "6p", "7p", "8p", "9p", "10p", "11p"];
				
			let svg = d3.select(chartId)
				.append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom)
				.append("g");

			let dayLabels = svg.selectAll(".dayLabel")
				.data(days).enter().append("text")
                .text(d => d)
                .attr("x", 0)
                .attr("y", (d, i) => i * gridSize)
				.style("text-anchor", "end")
				.attr("class", (d, i) => ((i >= 0 && i <= 4) ? "dayLabel mono axis axis-workweek" : "dayLabel mono axis"));
				
			let timeLabels = svg.selectAll(".timeLabel")
				.data(times)
				.enter().append("text")
				.text(d => d)
				.attr("x", (d, i) => i * gridSize)
				.attr("y", 0)
				.style("text-anchor", "middle")
				.attr("class", (d, i) => ((i >= 7 && i <= 16) ? "timeLabel mono axis axis-worktime" : "timeLabel mono axis"));
				
			//let colorScale = d3.scale.quantile()
			//	.domain([0, buckets - 1, d3.max(data, d => d.value)])
			//	.range(colors);
				
			let cards = svg.selectAll(".hour").data([...foreGrid.getAllDays()], d => formatDate(d.startTime));
			
			cards.append("title");
			
			cards.enter()
                .append("image").attr("x", d => d.hour * gridSize).attr("y", d => d.day * gridSize)
                .attr("rx", 4).attr("ry", 4)
                .attr("class", "hour bordered")
                .attr("width", gridSize).attr("height", gridSize)
                .attr("xlink:href", d => d.icon)
                .attr("xlink:title", d => d.shortForecast + ", " + d.temperature);
            cards.exit().remove();
		};
		
		getDateString = (date, dateFormat) => new Intl.DateTimeFormat('en-US', dateFormat).format(date);
		
		formatDate = (date, dateFormat = hourFormat) => (date instanceof Date) ? getDateString(date, dateFormat) : date;
		
		buildCell = x => {
			const td = document.createElement('TD');
			td.appendChild(x);
			return td;
		};

		buildTextCell = x => buildCell(document.createTextNode(x));
		
		buildImage = (src, text) => {
			const img = new Image();
			img.src = src;
			img.title = img.alt = text;
			return img;
		};
		
		getDateRange = (start, end) => formatDate(start) + " to " + formatDate(end);

		addRow = (image, imageAlt, start, temp, end, wind) => {
			const tableBody = document.getElementById("data");
			const tr = document.createElement('TR');
			const td = (image && image.length > 0) ? 
			buildCell(buildImage(image, imageAlt)) : buildTextCell(image);
			tr.appendChild(td);
			
			const elemTexts = [ getDateRange(start, end), temp, wind ];
			elemTexts.map(buildTextCell).forEach(x => tr.appendChild(x));
			tableBody.appendChild(tr);
		};

		getDate = strDate => new Date(strDate);
		
		getWind = period => period.windDirection + " " + period.windSpeed;

		parseForecast = forecast => {
			if (forecast.properties && forecast.properties.periods) {
				heatmapChart("#searchResults", forecast.properties.periods, getTopOffset());
				//forecast.properties.periods.forEach(currPeriod =>
				//	addRow(currPeriod.icon, currPeriod.shortForecast, getDate(currPeriod.startTime),
				//		currPeriod.temperature, getDate(currPeriod.endTime), getWind(currPeriod)));
			}
		};
		
		formattedNum = x => Number.parseFloat(x).toFixed(2);
		
		getFarenheit = x => (x * 9/5) + 32;

		setText = (tag, text) => document.getElementById(tag).innerText = text;

		getWindChill = windChill => (windChill < 31) ? ", " + windChill + "F wind chill" : "";

		getConditionsText = (desc, temp, windChill) => desc + ", " + temp + "F degrees" + getWindChill(windChill);
		
		setImage = imgSrc => document.body.style.backgroundImage = "url(" + imgSrc + ")";

		getInches = meters => meters * inPerMeter;

		formatPrecipitation = properties => {
			var result = "";
			if (properties.precipitationLastHour.value) {
				result += formattedNum(getInches(properties.precipitationLastHour.value)) + "in precipitation in past hour";
			}
			if (properties.precipitationLast3Hours.value) {
				if (result) result += ", ";
				result += formattedNum(getInches(properties.precipitationLast3Hours.value)) + "in precipitation in past 3 hours";
			}
			if (properties.precipitationLast6Hours.value) {
				if (result) result += ", ";
				result += formattedNum(getInches(properties.precipitationLast6Hours.value)) + "in precipitation in past 6 hours";
			}
			return result;
		};
        
        getTopOffset = () => document.querySelector('#currLocation').parentElement.offsetHeight + 15;

		parseConditions = conditions => {
			if (conditions.properties && conditions.properties.barometricPressure &&
				conditions.properties.barometricPressure.value) {
				const inHg = conditions.properties.barometricPressure.value * inHgPerPa;
				setText("barometricPressure", formattedNum(inHg) + " inches Hg, " +
					formattedNum(conditions.properties.relativeHumidity.value) + "% relative humidity");

				const windChill = formattedNum(getFarenheit(conditions.properties.windChill.value));
				const currTemp = formattedNum(getFarenheit(conditions.properties.temperature.value));
				const desc = conditions.properties.textDescription;
				setText("currTemp", getConditionsText(desc, currTemp, windChill));

				setText("currTime", formatDate(getDate(conditions.properties.timestamp), hourMinFormat));

				setText("precipitation", formatPrecipitation(conditions.properties));
				
				setImage(conditions.properties.icon.replace("medium", "large"));
				
				document.querySelector('#searchResults').style.top = getTopOffset() + "px";
			}
		};
		
		startCall = (url, callback) => fetch(url, geoHeaders).then(response => response.json()).then(callback);
		
		getPosition = callback => {
			const enteredLoc = document.getElementById("currLocation").value;
			const DEF_LOC = (enteredLoc) ? enteredLoc : HOME_LOC;
			if (!enteredLoc && ('geolocation' in navigator || navigator.geolocation)) {
				navigator.geolocation.getCurrentPosition(x => callback(x.coords.latitude + "," + x.coords.longitude),
					err => callback(DEF_LOC), geoOptions);
			} else {
				callback(DEF_LOC);
			}
		};
		
		getDistance = (here, far) => Math.sqrt(Math.pow((here[0] - far[0]), 2) + Math.pow((here[1] - far[1]), 2));

		compDist = (l, r) => (l.dist < r.dist) ? -1 : (l.dist > r.dist) ? 1 : 0;
		
		getClosestStation = (pos, stations) =>
			stations
				.map(x => ({ src: x, dist: getDistance(pos, x.geometry.coordinates)}))
				.sort(compDist)
				.map(x => x.src);
		
		loadOption = (opt, { geometry: { coordinates: [long, lat] }, properties: { name: statName } }) => {
			opt.value = lat + "," + long;
			opt.text = statName;
			return opt;
		};

		buildOption = station => loadOption(document.createElement("option"), station);

		buildAlternates = distStations => {
			var locs = document.getElementById("locations");
			if (locs.options.length) Array.from(Array(locs.options.length)).forEach(x => locs.remove(0));
			distStations.map(buildOption).forEach(opt => locs.add(opt, null));
		};
		
		getMyConditions = srcPos =>
			stations => {
				const distStations = getClosestStation(srcPos, stations.features);
				buildAlternates(distStations);
				startCall("https://api.weather.gov/stations/" + distStations[0].properties.stationIdentifier + "/observations/latest", parseConditions);
			};

		findStationByPosition = pos => {
			document.getElementById("currLocation").value = pos;
			startCall("https://api.weather.gov/points/" + pos + "/stations", getMyConditions(pos.split(",").reverse()));
			startCall("https://api.weather.gov/points/" + pos + "/forecast/hourly", parseForecast);
		};
		
		getStation = () => {
			document.getElementById("searchResults").innerHtml = '';
			getPosition(findStationByPosition);
		};
		
		useSelectedLocation = x => {
			document.getElementById("currLocation").value = document.getElementById("locations").value;
			getStation();
		};
		
		window.onload = () => {
			document.querySelector('#refresh').addEventListener('click', getStation);
			document.querySelector('#currLocation').addEventListener('change', getStation);
			document.getElementById("locations").addEventListener('change', useSelectedLocation);
			getStation();
		};
	</script>
	<body>
		<div class="conditions centered">
			<label for="location">Location: </label><input type="text" id="currLocation" name="location">
			<input type="button" value="Refresh" id="refresh">
			<div><h3>Weather</h3> (conditions as of <span id="currTime"></span> @ <select id="locations"></select>)</div>
			<div id="currTemp"></div>
			<div id="barometricPressure"></div>
			<div id="precipitation"></div>
		</div>
		<div id="searchResults" class="centered"></div>
	</body>
</html>